@page "/upload-tasks"

@inject ITaskService TaskService
@inject IMenuService MenuService

<h1>Upload tasks</h1>
<DrugnDrop OnReadClickCallback="@ReadFile" OnClearClickCallback="@ClearFiles" />
<br />
<input type="checkbox" @bind=_firstRowIsHeader id="firstRowIsHeader" />
<label for="firstRowIsHeader">Treat first row as header</label>
<XlsxReader OnSaveClickCallback="@SaveFile" Reader="@_reader" Message="@_message" FirstRowIsHeader="@_firstRowIsHeader" />

@code 
{
    private IFileReaderRef _reader = null;

    private string _message = string.Empty;

    private bool _firstRowIsHeader = true;

    private async Task ReadFile(IFileReaderRef reader)
    {
        _reader = reader;
        StateHasChanged();
    }

    private async Task ClearFiles()
    {
        _reader = null;
        _message = string.Empty;
        StateHasChanged();
    }

    private async Task SaveFile(TablesModel file)
    {
        var errors = new List<string>();
        foreach (var table in file.Tables)
        {
            foreach (var row in table.Body)
            {
                try
                {
                    var task = new TaskPost
                    {
                        Name = row.Cells[3].Value ?? string.Empty,
                        Body = row.Cells[4].Value ?? string.Empty,
                    };

                    switch (row.Cells[0].Value)
                    {
                        case "1":
                            task.ModuleId = Module.First;
                            break;

                        case "2":
                            task.ModuleId = Module.Second;
                            break;

                        case "3":
                            task.ModuleId = Module.Third;
                            break;

                        case "4":
                            task.ModuleId = Module.Fourth;
                            break;

                        default:
                            throw new ArgumentException(row.ToString(), nameof(Module));
                    }

                    switch (row.Cells[5].Value.ToLower())
                    {
                        case "free":
                            task.TaskTypeId = TaskType.Free;
                            break;

                        case "single":
                            task.TaskTypeId = TaskType.Single;
                            break;

                        case "multiple":
                            task.TaskTypeId = TaskType.Multiple;
                            break;

                        case "match":
                            task.TaskTypeId = TaskType.Match;
                            break;

                        default:
                            throw new ArgumentException(row.ToString(), nameof(Module));
                    }

                    task.Answers = (row.Cells[6].Value ?? string.Empty).Split(new [] { ';' }, StringSplitOptions.RemoveEmptyEntries).ToList();
                    task.Rights = (row.Cells[7].Value ?? string.Empty).Split(new [] { ';' }, StringSplitOptions.RemoveEmptyEntries).ToList();
                    task.Topics = (row.Cells[1].Value ?? string.Empty).Split(new [] { ';' }, StringSplitOptions.RemoveEmptyEntries).ToList();
                    task.Tags = (row.Cells[2].Value ?? string.Empty).Split(new [] { ';' }, StringSplitOptions.RemoveEmptyEntries).ToList();

                    await TaskService.CreateAsync(task);
                }
                catch (Exception e)
                {
                    errors.Add(e.Message);
                }
            }
        }

        if (errors.Any())
        {
            errors = errors.Prepend($"{errors.Count} errors occured:").ToList();
            _message = string.Join(Environment.NewLine, errors);
        }
        else
        {
            _message = "Tasks saved in repository.";
        }

        StateHasChanged();

        MenuService.HasConflicts = (await TaskService.GetTaskConflicts()).Any();
        MenuService.NotifyChanged();
    }
}