@inject IFileReaderService FileReaderService;

<div class="@IpDropClass">
    <input type="file"
           class="clickable"
           accept=".xlsx"
           @ref=_dropTargetInput
           @onchange="OnInputChange"
           @ondragenter=OnIpDragEnter
           @ondragleave=OnIpDragLeave
           multiple />
    Drop .xlsx file here or click me.

    @foreach (var fileInfo in IpFileList.Select(x => x.Key))
    {
        <br />
        @fileInfo.Name
    }
</div>

<button @onclick="ReadClick" class="btn btn-primary">Parse</button>
<button @onclick="ClearClick" class="btn btn-primary">Clear</button>

<style>
    .@dropTargetClass {
        display: block;
        padding: 20px;
        margin-bottom: 10px;
        border: 1px dashed black;
        border-radius: 5px;
        position: relative;
    }

    .@dropTargetDragClass {
        border-color: orangered;
        font-weight: bold;
    }

    input.clickable {
        position: absolute;
        width: 100%;
        height: 100%;
        opacity: 0;
        margin-top: -20px;
        margin-left: -20px;
        cursor: pointer;
    }
</style>

@code 
{
    [Parameter]
    public EventCallback<IFileReaderRef> OnReadClickCallback { get; set; }

    [Parameter]
    public EventCallback OnClearClickCallback { get; set; }

    ElementReference _dropTargetInput;

    IFileReaderRef ipReference;

    private readonly List<string> _ipdropClasses = new List<string>() { dropTargetClass };

    string IpDropClass => string.Join(" ", _ipdropClasses);

    const string dropTargetDragClass = "droptarget-drag";

    const string dropTargetClass = "droptarget";

    List<KeyValuePair<IFileInfo, AsyncDisposableStream>> IpFileList { get; } = new List<KeyValuePair<IFileInfo, AsyncDisposableStream>>();

    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        if (isFirstRender)
        {
            ipReference = FileReaderService.CreateReference(_dropTargetInput);
        }
    }

    public void OnIpDragEnter(EventArgs e) => _ipdropClasses.Add(dropTargetDragClass);

    public void OnIpDragLeave(EventArgs e) => _ipdropClasses.Remove(dropTargetDragClass);

    public async Task OnInputChange(EventArgs e)
    {
        _ipdropClasses.Remove(dropTargetDragClass);
        StateHasChanged();
        await RefreshFileList();
    }

    private async Task RefreshFileList()
    {
        await ClearAsync();

        foreach (var file in await ipReference.EnumerateFilesAsync())
        {
            var fileInfo = await file.ReadFileInfoAsync();
            IpFileList.Add(new KeyValuePair<IFileInfo, AsyncDisposableStream>(fileInfo, await file.OpenReadAsync()));
        }

        StateHasChanged();
    }

    public async Task ClearClick()
    {
        await ClearAsync();
        await ipReference.ClearValue();

        await RefreshFileList();
    }

    private async Task ClearAsync()
    {
        foreach (var disposable in IpFileList.Select(x => x.Value))
        {
            await disposable.DisposeAsync();
        }

        IpFileList.Clear();

        await OnClearClickCallback.InvokeAsync(null);
    }

    public async Task ReadClick()
    {
        await OnReadClickCallback.InvokeAsync(ipReference);
    }
}