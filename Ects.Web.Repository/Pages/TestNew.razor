@page "/test-new"
@*@attribute [Authorize]*@

@inject NavigationManager NavigationManager

<h1>Create test</h1>

<div class="row">
    <input type="text"
           class="searchTerm"
           placeholder="Type search pattern..."
           @bind-value="_searchTerm"
           @bind-value:event="oninput">
    <button type="button" class="searchButton" @onclick="Search">Search</button>
</div>

@*<div class="row">
        <select class="mr-2" value="@(_filters.TaskTypeId.HasValue ? _filters.TaskTypeId.ToString() : "null")"
                @onchange="@(e => OnTypeFilterChanged(e.Value.ToString()))">
            <option value="null">Select type</option>
            <option value="@TaskType.Free.ToString()">Free answer</option>
            <option value="@TaskType.Single.ToString()">Single answer</option>
            <option value="@TaskType.Multiple.ToString()">Multiple answers</option>
            <option value="@TaskType.Match.ToString()">Match answers</option>
        </select>

        <select class="mr-2" value="@(_filters.ModuleId.HasValue ? _filters.ModuleId.ToString() : "null")"
                @onchange="@(e => OnModuleFilterChanged(e.Value.ToString()))">
            <option value="null">Select module</option>
            <option value="@Module.First.ToString()">First module</option>
            <option value="@Module.Second.ToString()">Second module</option>
            <option value="@Module.Third.ToString()">Third module</option>
            <option value="@Module.Fourth.ToString()">Fourth module</option>
        </select>

        <select @bind-value="@_filters.SortTypeId" @bind-value:event="onchange">
            <option value="@SortType.Newest">Newest</option>
            <option value="@SortType.Oldest">Oldest</option>
        </select>
    </div>*@

@if (_loading)
{
    <div class="spinner-border spinner-border-sm"></div>
}

@if (_tasks != null)
{
    <div class="scrollable-container mt-2 mb-2">
        <div style="max-height: 100%; overflow: auto;">
            @foreach (var task in _tasks)
            {
                var taskId = task.Id;
                <div class="card"
                     style=@(_markedTasks.Contains(taskId) ? "background-color: #00b4cc" : "background-color: azure")
                     @onclick="@(() => MarkTask(taskId.ToString()))">
                    <label class="card-header">@task.Name</label>
                    <div class="card-body">
                        <div class="row">
                            Description: @task.Description
                        </div>

                        <hr />

                        <text>@((MarkupString)Markdown.ToHtml(task.Body, _pipeline))</text>

                        <hr />

                        <div class="row">
                            Tags:
                            @foreach (var tag in FakeRepository.Tags.Where(t => FakeRepository.QuestionTagLinks.Exists(l => l.QuestionId == task.Id && l.TagId == t.Id)).Select(_ => _.Value))
                            {
                                <div class="ml-1">@tag;</div>
                            }
                        </div>

                        <div class="text-muted">@(task.ChangedAtUtc ?? task.CreatedAtUtc)</div>
                    </div>
                </div>
            }
        </div>
    </div>

    <Ects.Web.Repository.Pages.Components.Pager PageSize="@PageSize" ItemsCount="@_tasksCount" OnChangePageCallback="@ChangePage" />
}

<hr />

<div>
    <div class="row">
        <input type="text"
               placeholder="Type variant name..."
               @bind-value="_variantName"
               @bind-value:event="oninput">
    </div>

    <div class="row">
        <Ects.Web.Repository.Pages.Components.SearchByType OnAddItemCallback="AddTag"
                                                           OnRemoveItemCallback="RemoveTag"
                                                           Items="@_existingTags" />
    </div>
</div>

<div class="btn btn-primary mt-2" @onclick="CreateVariant">
    @if (_loadingCreate)
    {
        <span class="spinner-border spinner-border-sm mr-1"></span>
    }
    Create
</div>
<div class="btn btn-primary mt-2" @onclick="@(() => NavigationManager.NavigateTo("variant-index"))">Cancel</div>

<style>
    .row {
        margin-left: 0px
    }

    .scrollable-container {
        height: calc(100vh - 300px);
        position: relative;
    }

    .searchTerm {
        width: calc(100% - 100px);
        border: 3px solid #00B4CC;
        border-right: none;
        padding: 5px;
        height: 36px;
        border-radius: 5px 0 0 5px;
        outline: none;
        color: #9DBFAF;
    }

        .searchTerm:focus {
            color: #00B4CC;
        }

    .searchButton {
        width: 100px;
        height: 36px;
        border: 1px solid #00B4CC;
        background: #00B4CC;
        text-align: center;
        color: #fff;
        border-radius: 0 5px 5px 0;
        cursor: pointer;
        font-size: 20px;
    }
</style>

@code
{
    private IDictionary<string, bool> _existingTags = new Dictionary<string, bool>();

    public IEnumerable<string> Tags { get; set; } = new List<string>();

    public const int PageSize = 10;

    private bool _loading = true;

    private bool _loadingCreate = false;

    private IEnumerable<Question> _tasks = null;

    private IEnumerable<long> _markedTasks = new List<long>();

    private string _variantName = string.Empty;

    private long _tasksCount = 0;

    private readonly MarkdownPipeline _pipeline = new MarkdownPipelineBuilder().UseSyntaxHighlighting().Build();

    private string _searchTerm;

    //private TaskFilters _filters = new TaskFilters
    //{
    //    ModuleId = null,
    //    TaskTypeId = null,
    //    SortTypeId = SortType.Newest,
    //    SearchTerm = string.Empty,
    //};

    protected override async Task OnInitializedAsync()
    {
        _loading = true;

        _tasksCount = FakeRepository.Questions.Count();
        await ChangePage(1);

        _loading = false;
        StateHasChanged();
    }

    private void AddTag(string tag)
    {
        var tags = Tags.ToList();
        tags.Add(tag);
        Tags = tags;

        if (_existingTags.ContainsKey(tag))
        {
            _existingTags[tag] = true;
        }
        else
        {
            _existingTags.Add(tag, true);
        }
    }

    private void RemoveTag(string tag)
    {
        var tags = Tags.ToList();
        tags.Remove(tag);
        Tags = tags;
        _existingTags[tag] = false;
    }

    private void MarkTask(string taskIdString)
    {
        var taskId = long.Parse(taskIdString);
        var markedTasks = _markedTasks.ToList();

        if (markedTasks.Contains(taskId))
        {
            markedTasks.Remove(taskId);
        }
        else
        {
            markedTasks.Add(taskId);
        }

        _markedTasks = markedTasks;
        StateHasChanged();
    }

    private async Task ChangePage(int page)
    {
        if (!string.IsNullOrEmpty(_searchTerm))
            _tasks = FakeRepository.Questions.Where(_ => (_.Name.Contains(_searchTerm) || _.Description.Contains(_searchTerm) || _.Body.Contains(_searchTerm))).ToList();
        else
            _tasks = FakeRepository.Questions.Skip(page * PageSize >= FakeRepository.Questions.Count ? 0 : page * PageSize).Take(PageSize).ToList();
        //_tasks = await TaskService.GetTasksWithPaginationAndFiltersAsync(page, PageSize, _filters);
        StateHasChanged();
    }

    private async Task Search()
    {
        _tasks = null;
        _tasksCount = 0;
        _loading = true;
        StateHasChanged();

        _tasksCount = FakeRepository.Questions.Where(_ => (_.Name.Contains(_searchTerm) || _.Description.Contains(_searchTerm) || _.Body.Contains(_searchTerm))).Count();
        //_tasksCount = await TaskService.GetTasksCountWithFilters(_filters);
        await ChangePage(1);

        _loading = false;
        StateHasChanged();
    }

    private async Task CreateVariant()
    {
        _loadingCreate = true;
        StateHasChanged();

        FakeRepository.Tests.Add(
            new Test
            {
                Id = FakeRepository.Tests.Count,
                Name = _variantName,
                Description = "Description",
                NamespaceId = 0,
                Version = 0,
                ChangedAtUtc = null,
                ChangedBy = null,
                CreatedAtUtc = DateTime.UtcNow,
                CreatedBy = 0,
                IsActive = true,
            });

        var count = 0;
        foreach (var taskId in _markedTasks)
        {
            FakeRepository.TestQuestionLinks.Add(
                new TestQuestionLink
                {
                    Id = FakeRepository.TestQuestionLinks.Count,
                    Order = count,
                    Value = 1,
                    QuestionId = taskId,
                    TestId = FakeRepository.Tests.Count - 1,
                });
            count++;
        }

        foreach (var tag in Tags)
        {
            if (!FakeRepository.Tags.Select(_ => _.Value).Contains(tag))
                FakeRepository.Tags.Add(
                    new Tag
                    {
                        Id = FakeRepository.Tags.Count,
                        Key = "test",
                        Value = tag,
                    });

            FakeRepository.TestTagLinks.Add(
                new TestTagLink
                {
                    Id = FakeRepository.QuestionTagLinks.Count,
                    TestId = FakeRepository.Tests.Count - 1,
                    TagId = FakeRepository.Tags.Count - 1,
                });
        }

        //await VariantService.CreateAsync(
        //    new VariantPost
        //    {
        //        ModuleId = _module,
        //        Name = _variantName,
        //        TaskIds = _markedTasks,
        //    });

        NavigationManager.NavigateTo("");
    }
}